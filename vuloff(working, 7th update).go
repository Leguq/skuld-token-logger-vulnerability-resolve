package main

import (
    "fmt"
    "io"
    "log"
    "os"
    "path/filepath"
    "syscall"
    "time"
    "golang.org/x/sys/windows/registry"
    "golang.org/x/sys/windows/svc"
    "golang.org/x/sys/windows/svc/mgr"
    "golang.org/x/sys/windows"
)

// Service name
const serviceName = "MyRegistryMonitorService"

// myService represents the service structure
type myService struct{}

// Execute handles service commands
func (m *myService) Execute(args []string, r <-chan svc.ChangeRequest, s chan<- svc.Status) (bool, uint32) {
    const cmdsAccepted = svc.AcceptStop | svc.AcceptShutdown
    s <- svc.Status{State: svc.StartPending}
    go m.run() // Start the monitoring function
    s <- svc.Status{State: svc.Running, Accepts: cmdsAccepted}

    for c := range r {
        switch c.Cmd {
        case svc.Stop, svc.Shutdown:
            s <- svc.Status{State: svc.StopPending}
            return false, 0
        }
    }
    return false, 0
}

// run is the monitoring function that checks the registry
func (m *myService) run() {
    for {
        monitorRegistryKey() // Call your registry monitoring function
        time.Sleep(50 * time.Millisecond)
    }
}

// monitorRegistryKey opens, monitors, and deletes the registry key
func monitorRegistryKey() {
    key, err := registry.OpenKey(registry.CURRENT_USER, `Software\Classes\ms-settings\shell\open\command`, registry.READ)
    if err != nil {
        log.Printf("Error opening registry key: %v", err)
        return
    }
    defer key.Close()

    log.Println("Registry key exists and is being monitored.")

    err = registry.DeleteKey(registry.CURRENT_USER, `Software\Classes\ms-settings\shell\open\command`)
    if err != nil {
        log.Printf("Error deleting registry key: %v", err)
        return
    }
    log.Println("Registry key deleted successfully.")
}

// isAdmin checks if the process is running with elevated privileges
func isAdmin() bool {
    var sid *windows.SID
    err := windows.AllocateAndInitializeSid(
        &windows.SECURITY_NT_AUTHORITY,
        2,
        windows.SECURITY_BUILTIN_DOMAIN_RID,
        windows.DOMAIN_ALIAS_RID_ADMINS,
        0, 0, 0, 0, 0, 0,
        &sid)
    if err != nil {
        return false
    }
    defer windows.FreeSid(sid)

    token := windows.Token(0)
    isMember, err := token.IsMember(sid)
    if err != nil {
        return false
    }

    return isMember
}

// elevateAdmin restarts the process with admin privileges if needed
func elevateAdmin() {
    if isAdmin() {
        return
    }

    verb := "runas"
    exe, _ := os.Executable()
    cmd := exe
    args := os.Args[1:]

    var verbUTF16 *uint16
    verbUTF16, _ = syscall.UTF16PtrFromString(verb)

    var exeUTF16 *uint16
    exeUTF16, _ = syscall.UTF16PtrFromString(cmd)

    var cwdUTF16 *uint16
    cwdUTF16, _ = syscall.UTF16PtrFromString(".")

    var argv []*uint16
    for _, arg := range args {
        argv = append(argv, syscall.StringToUTF16Ptr(arg))
    }

    err := windows.ShellExecute(0, verbUTF16, exeUTF16, nil, cwdUTF16, windows.SW_NORMAL)
    if err != nil {
        log.Fatalf("Failed to restart as admin: %v", err)
    }

    os.Exit(0)
}

// copyToStartup copies the executable to the Startup folder if it does not already exist
func copyToStartup() {
    exePath, err := os.Executable()
    if err != nil {
        log.Fatalf("failed to get executable path: %v", err)
    }

    startupPath := filepath.Join(`C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp`, filepath.Base(exePath))

    // Check if the file already exists
    if _, err := os.Stat(startupPath); err == nil {
        log.Println("Executable already exists in Startup folder, skipping copy.")
        return
    }

    err = copyFile(exePath, startupPath)
    if err != nil {
        log.Fatalf("failed to copy executable to Startup folder: %v", err)
    }

    log.Println("Executable copied to Startup folder successfully.")
}

// copyFile copies a file from src to dst
func copyFile(src, dst string) error {
    in, err := os.Open(src)
    if err != nil {
        return err
    }
    defer in.Close()

    out, err := os.Create(dst)
    if err != nil {
        return err
    }
    defer out.Close()

    _, err = io.Copy(out, in)
    if err != nil {
        return err
    }

    return out.Sync()
}

// installService installs and starts the service
func installService() {
    exePath, err := filepath.Abs(os.Args[0])
    if err != nil {
        log.Fatalf("failed to get executable path: %v", err)
    }

    // Copy executable to Startup folder
    copyToStartup()

    // Open the service manager
    scm, err := mgr.Connect()
    if err != nil {
        log.Fatalf("failed to connect to service manager: %v", err)
    }
    defer scm.Disconnect()

    // Create the service
    service, err := scm.CreateService(serviceName, exePath, mgr.Config{StartType: mgr.StartAutomatic}, "is", "pw")
    if err != nil {
        log.Fatalf("failed to create service: %v", err)
    }
    defer service.Close()

    // Start the service
    err = service.Start()
    if err != nil {
        log.Fatalf("failed to start service: %v", err)
    }

    fmt.Println("Service installed and started successfully.")
}

// uninstallService uninstalls the service
func uninstallService() {
    scm, err := mgr.Connect()
    if err != nil {
        log.Fatalf("failed to connect to service manager: %v", err)
    }
    defer scm.Disconnect()

    service, err := scm.OpenService(serviceName)
    if err != nil {
        log.Fatalf("failed to open service: %v", err)
    }
    defer service.Close()

    // Stop the service by sending a control signal
    status, err := service.Control(svc.Stop)
    if err != nil {
        log.Printf("failed to stop service: %v", err)
    } else {
        log.Printf("Service stop command sent, current status: %v", status.State)
    }

    // Delete the service
    err = service.Delete()
    if err != nil {
        log.Fatalf("failed to delete service: %v", err)
    }

    fmt.Println("Service uninstalled successfully.")
}

func main() {
    elevateAdmin() // Check and elevate privileges if needed
    copyToStartup()

    if len(os.Args) > 1 {
        switch os.Args[1] {
        case "install":
            installService()
            return
        case "uninstall":
            uninstallService()
            return
        }
    }

    isInteractive, err := svc.IsAnInteractiveSession()
    if err != nil {
        log.Fatalf("failed to determine if we are running in an interactive session: %v", err)
    }
    if isInteractive {
        s := &myService{}
        s.run()
    } else {
        err = svc.Run(serviceName, &myService{})
        if err != nil {
            log.Fatalf("failed to run service: %v", err)
        }
    }
}
